<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Funko Image Extractor (Advanced)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7fafc; /* Tailwind gray-100 */
        }
        .loader, .image-loader-spinner {
            border: 4px solid #e5e7eb; /* Tailwind gray-200 */
            border-top: 4px solid #3b82f6; /* Tailwind blue-500 */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        .image-loader-spinner { width: 32px; height: 32px; } /* Larger for images */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .image-item {
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .image-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .image-container {
            background-color: #f9fafb; /* Tailwind gray-50 */
            aspect-ratio: 1 / 1; /* Make it square */
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.375rem; /* Tailwind rounded-md */
            overflow: hidden; /* Ensure img corners are also rounded if img itself is square */
        }
        .image-container img {
            max-height: 100%;
            max-width: 100%;
            object-fit: contain;
            transition: opacity 0.3s ease-in-out;
        }
        .status-message { margin-top: 1rem; padding: 1rem; border-radius: 0.5rem; font-size: 0.95rem; }
        .status-success { background-color: #ecfdf5; color: #065f46; border: 1px solid #a7f3d0; }
        .status-error   { background-color: #fff1f2; color: #9f1239; border: 1px solid #fecdd3; }
        .status-info    { background-color: #eff6ff; color: #1e40af; border: 1px solid #bfdbfe; }
        .status-warning { background-color: #fffbeb; color: #92400e; border: 1px solid #fde68a; }

        .pid-result-block {
            opacity: 0;
            transform: translateY(10px);
            animation: fadeInSlideUp 0.5s ease-out forwards;
        }
        @keyframes fadeInSlideUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body class="text-gray-800 antialiased">
    <div class="container mx-auto max-w-3xl px-4 py-8 md:py-12">
        <div class="bg-white p-6 md:p-8 rounded-xl shadow-2xl">
            <header class="mb-8 text-center">
                <svg class="w-16 h-16 text-blue-600 mx-auto mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                <h1 class="text-4xl font-bold text-gray-800">Funko Image Extractor</h1>
                <p class="text-gray-600 mt-2 text-lg">
                    Enter Funko Product IDs (PIDs) to fetch content via
                    <code class="bg-blue-100 text-blue-700 px-1 py-0.5 rounded text-sm">corsproxy.io</code>
                    and extract product images (JPG/PNG only).
                </p>
            </header>

            <div class="mb-6">
                <label for="funkoPidTextarea" class="block text-sm font-semibold text-gray-700 mb-2">Funko Product IDs (PIDs):</label>
                <textarea id="funkoPidTextarea" class="w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-shadow" rows="3" placeholder="Enter PIDs, separated by commas, spaces, or new lines (e.g., 84946, 72406)"></textarea>
            </div>

            <div class="flex space-x-4">
                <button id="fetchButton" class="flex-grow bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-full shadow-md hover:shadow-lg transform hover:scale-105 transition duration-300 ease-in-out text-lg flex items-center justify-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                    Fetch and Extract Images
                </button>
                <button id="clearResultsButton" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-full shadow-md hover:shadow-lg transform hover:scale-105 transition duration-300 ease-in-out text-lg flex items-center justify-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    Clear Results
                </button>
            </div>

            <div id="statusArea" class="mt-6 min-h-[60px]">
                </div>

            <div id="resultsArea" class="mt-6 space-y-6">
                </div>
        </div>

        <footer class="text-center text-gray-500 mt-10 text-sm">
            <p>Using corsproxy.io for data fetching. API Key is hardcoded.</p>
        </footer>
    </div>

    <script>
        const funkoPidTextarea = document.getElementById('funkoPidTextarea');
        const fetchButton = document.getElementById('fetchButton');
        const clearResultsButton = document.getElementById('clearResultsButton');
        const statusArea = document.getElementById('statusArea');
        const resultsArea = document.getElementById('resultsArea');

        const FUNKO_TARGET_URL_BASE = 'https://funko.com/on/demandware.store/Sites-FunkoUS-Site/en_US/Wishlist-GetProduct?pid=';
        const FUNKO_IMAGE_BASE_URL = 'https://funko.com/dw/image/v2/BGTS_PRD/';
        const CORS_PROXY_API_KEY = 'eb06c81a'; 
        const CORS_PROXY_BASE_URL = 'https://corsproxy.io/';

        const emptyStateHTML = `
            <div id="emptyStateResults" class="text-center p-10 border-2 border-dashed border-gray-300 rounded-lg opacity-0 transition-opacity duration-500 ease-out">
                <svg class="mx-auto h-16 w-16 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                    <path vector-effect="non-scaling-stroke" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
                <h3 class="mt-4 text-lg font-medium text-gray-700">Ready to find some images?</h3>
                <p class="mt-1 text-sm text-gray-500">Enter Funko PIDs above and click "Fetch" to begin.</p>
            </div>`;

        function setInitialEmptyState() {
            resultsArea.innerHTML = emptyStateHTML;
            // Allow CSS to handle initial opacity, then trigger transition
            setTimeout(() => {
                const emptyStateDiv = document.getElementById('emptyStateResults');
                if (emptyStateDiv) emptyStateDiv.style.opacity = '1';
            }, 50);
        }
        setInitialEmptyState(); // Set on page load

        clearResultsButton.addEventListener('click', () => {
            setInitialEmptyState();
            statusArea.innerHTML = '';
            funkoPidTextarea.value = '';
            displayStatus('Results cleared. Ready for new PIDs.', 'info');
        });

        fetchButton.addEventListener('click', async () => {
            const pidsString = funkoPidTextarea.value.trim();
            const pids = pidsString.split(/[\s,]+/).map(pid => pid.trim()).filter(pid => pid !== '');

            if (pids.length === 0) {
                displayStatus('Please enter at least one Funko Product ID (PID).', 'error');
                if (!resultsArea.innerHTML.includes('pid-result-block')) { // Only reset if no results shown
                    setInitialEmptyState();
                }
                return;
            }

            fetchButton.disabled = true;
            fetchButton.innerHTML = `Processing PIDs... <div class="loader"></div>`;
            resultsArea.innerHTML = ''; 
            let overallSuccessCount = 0;

            for (let i = 0; i < pids.length; i++) {
                const pid = pids[i];
                const currentPidStatusMessage = `Processing PID ${i + 1} of ${pids.length}: <strong>${pid}</strong>`;
                displayStatus(currentPidStatusMessage, 'info');

                const targetUrl = `${FUNKO_TARGET_URL_BASE}${pid}`;
                const proxyFetchUrl = `${CORS_PROXY_BASE_URL}?key=${CORS_PROXY_API_KEY}&url=${encodeURIComponent(targetUrl)}`;

                const pidResultContainerId = `pid-result-${pid.replace(/[^a-zA-Z0-9]/g, "")}-${i}`;
                const pidResultBlock = document.createElement('div');
                pidResultBlock.id = pidResultContainerId;
                pidResultBlock.className = 'pid-result-block mb-6 p-4 border border-gray-200 rounded-lg shadow'; // Animation class
                pidResultBlock.innerHTML = `<h3 class="text-xl font-semibold text-gray-800 mb-2">Results for PID: ${pid}</h3>
                                            <div class="pid-status-message text-sm mb-2"></div>
                                            <div class="pid-image-gallery"></div>`;
                resultsArea.appendChild(pidResultBlock);
                
                // Trigger animation
                setTimeout(() => pidResultBlock.style.opacity = '1', 50);


                const pidStatusDiv = pidResultBlock.querySelector(`.pid-status-message`);
                const pidImageGalleryDiv = pidResultBlock.querySelector(`.pid-image-gallery`);
                pidStatusDiv.innerHTML = `<p class="text-blue-600">Fetching data via proxy...</p>`;

                try {
                    const response = await fetch(proxyFetchUrl);
                    if (!response.ok) {
                        let errorText = await response.text();
                        if (errorText.length > 150) errorText = errorText.substring(0, 150) + "...";
                        pidStatusDiv.innerHTML = `<p class="text-red-600 font-medium">Error fetching: ${response.status} ${response.statusText}.</p><p class="text-xs text-gray-500 mt-1">Proxy response: ${errorText}</p>`;
                        continue; 
                    }
                    const responseText = await response.text();
                    if (responseText.trim() === "") {
                        pidStatusDiv.innerHTML = `<p class="text-yellow-600 font-medium">Fetched successfully, but the response was empty.</p>`;
                        continue;
                    }
                    
                    const imageUrls = extractImageUrlsFromText(responseText, pidStatusDiv); // Pass pidStatusDiv for logging
                    if (imageUrls.size > 0) {
                        // pidStatusDiv message is now set within extractImageUrlsFromText based on parsing method
                        pidImageGalleryDiv.innerHTML = generateImagesHTMLForPid(imageUrls);
                        overallSuccessCount++;
                    } else {
                         pidStatusDiv.innerHTML = `<p class="text-yellow-600 font-medium">Data fetched successfully, but no JPG/PNG image URLs found after parsing.</p>`;
                    }

                } catch (error) {
                    pidStatusDiv.innerHTML = `<p class="text-red-600 font-medium">Network error or issue with proxy for PID ${pid}: ${error.message}</p>`;
                }
            }

            fetchButton.disabled = false;
            fetchButton.innerHTML = `<svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg> Fetch and Extract Images`;
            
            if (pids.length > 0) {
                if (overallSuccessCount > 0) {
                    displayStatus(`Batch processing complete. Successfully extracted images for ${overallSuccessCount} of ${pids.length} PIDs.`, 'success');
                } else {
                    displayStatus(`Batch processing complete. No images were successfully extracted for any of the ${pids.length} PIDs.`, 'warning');
                }
            } else if (pidsString !== "") { // User entered something but it was all invalid PIDs
                 displayStatus('No valid PIDs found to process.', 'error');
            }
            if (resultsArea.innerHTML.trim() === '') { // If all PIDs failed and results area is empty
                setInitialEmptyState();
            }
        });

        function displayStatus(message, type = 'info') {
            let typeClass = 'status-info';
            if (type === 'success') typeClass = 'status-success';
            if (type === 'error') typeClass = 'status-error';
            if (type === 'warning') typeClass = 'status-warning';
            statusArea.innerHTML = `<div class="status-message ${typeClass}">${message}</div>`;
        }

        function extractImageUrlsFromText(text, pidStatusDiv) {
            const foundUrls = new Set();
            const imageExtensions = /\.(png|jpg|jpeg)$/i;
            let extractionMethod = "Regex Fallback"; // Default if JSON parsing fails or finds nothing

            try {
                const jsonData = JSON.parse(text);
                let jsonUrlsFound = 0;

                function findUrlsRecursively(obj) {
                    if (!obj || typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') return;

                    if (Array.isArray(obj)) {
                        obj.forEach(item => findUrlsRecursively(item));
                    } else if (typeof obj === 'object') {
                        // Prioritize known Funko structures
                        let processedKnownPath = false;
                        if (obj.images && typeof obj.images === 'object') {
                            const imageSources = [];
                            if (obj.images['hi-res'] && Array.isArray(obj.images['hi-res'])) imageSources.push(...obj.images['hi-res']);
                            if (obj.images.views && Array.isArray(obj.images.views)) imageSources.push(...obj.images.views);
                            // Add other known paths like 'default', 'large', 'small', 'absomedium', 'zoom', 'swatch' etc.
                            ['default', 'large', 'small', 'absomedium', 'zoom', 'swatch'].forEach(key => {
                                if(obj.images[key] && Array.isArray(obj.images[key])) imageSources.push(...obj.images[key]);
                            });


                            if(imageSources.length > 0) {
                                imageSources.forEach(img => findUrlsRecursively(img));
                                processedKnownPath = true; // Indicate we've processed a primary image path
                            }
                        }
                        
                        // General check for 'url' property
                        if (typeof obj.url === 'string' && imageExtensions.test(obj.url)) {
                            let candidateUrlOrPath = obj.url;
                            let finalUrl;
                            if (candidateUrlOrPath.startsWith('http://') || candidateUrlOrPath.startsWith('https://') || candidateUrlOrPath.startsWith('//')) {
                                finalUrl = candidateUrlOrPath;
                            } else if (!candidateUrlOrPath.includes('://')) {
                                if (FUNKO_IMAGE_BASE_URL.endsWith('/') && candidateUrlOrPath.startsWith('/')) {
                                    finalUrl = FUNKO_IMAGE_BASE_URL + candidateUrlOrPath.substring(1);
                                } else if (!FUNKO_IMAGE_BASE_URL.endsWith('/') && !candidateUrlOrPath.startsWith('/')) {
                                    finalUrl = FUNKO_IMAGE_BASE_URL + '/' + candidateUrlOrPath;
                                } else {
                                    finalUrl = FUNKO_IMAGE_BASE_URL + candidateUrlOrPath;
                                }
                            }
                            if (finalUrl && !finalUrl.startsWith('data:')) {
                                foundUrls.add(finalUrl);
                                jsonUrlsFound++;
                            }
                             processedKnownPath = true; // Also mark as processed if direct url found
                        }

                        // If we didn't find images through a known path or direct 'url', then recurse all properties
                        if (!processedKnownPath) {
                             for (const key in obj) {
                                if (obj.hasOwnProperty(key)) {
                                    findUrlsRecursively(obj[key]);
                                }
                            }
                        }
                    }
                }
                findUrlsRecursively(jsonData);
                if (jsonUrlsFound > 0) {
                    extractionMethod = "JSON Parsing";
                }
            } catch (e) {
                // JSON parsing failed, will use regex fallback.
                 if(pidStatusDiv) pidStatusDiv.innerHTML += `<p class="text-xs text-yellow-700 mt-1">Note: Response was not valid JSON, or JSON parsing for images failed. Falling back to regex scan. Error: ${e.message.substring(0,100)}</p>`;
            }

            // Fallback to Regex if JSON parsing found nothing or failed
            if (foundUrls.size === 0) {
                extractionMethod = "Regex Fallback"; // Ensure it's set if JSON parsing yielded nothing
                let match;
                const imagePatternRegex = /([a-zA-Z0-9\/_.-]+\.(?:png|jpg|jpeg))/gi;
                while ((match = imagePatternRegex.exec(text)) !== null) {
                    let candidateUrlOrPath = match[1];
                    if (candidateUrlOrPath.length < 4) continue;
                    let finalUrl;
                    if (candidateUrlOrPath.startsWith('http://') || candidateUrlOrPath.startsWith('https://') || candidateUrlOrPath.startsWith('//')) {
                        finalUrl = candidateUrlOrPath;
                    } else if (!candidateUrlOrPath.includes('://')) {
                         if (FUNKO_IMAGE_BASE_URL.endsWith('/') && candidateUrlOrPath.startsWith('/')) {
                            finalUrl = FUNKO_IMAGE_BASE_URL + candidateUrlOrPath.substring(1);
                        } else if (!FUNKO_IMAGE_BASE_URL.endsWith('/') && !candidateUrlOrPath.startsWith('/')) {
                            finalUrl = FUNKO_IMAGE_BASE_URL + '/' + candidateUrlOrPath;
                        } else {
                            finalUrl = FUNKO_IMAGE_BASE_URL + candidateUrlOrPath;
                        }
                    }
                    if (finalUrl && !finalUrl.startsWith('data:')) {
                        foundUrls.add(finalUrl);
                    }
                }
            }
             if(pidStatusDiv && foundUrls.size > 0) {
                pidStatusDiv.innerHTML = `<p class="text-green-600 font-medium">Data processed (using ${extractionMethod}). Extracted ${foundUrls.size} image(s).</p>`;
            } else if (pidStatusDiv && foundUrls.size === 0) {
                // This state might be covered by parent function, but good to have a specific message if extraction yields nothing.
                pidStatusDiv.innerHTML = `<p class="text-yellow-600 font-medium">Data processed (using ${extractionMethod}), but no JPG/PNG image URLs found.</p>`;
            }

            return foundUrls;
        }

        function generateImagesHTMLForPid(urls) {
            if (!urls || urls.size === 0) {
                return ''; 
            }

            let html = `<div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3 mt-2">`;
            urls.forEach(url => {
                const filename = url.substring(url.lastIndexOf('/') + 1);
                const displayFilename = filename.length > 22 ? filename.substring(0, 19) + '...' : filename;
                html += `
                    <div class="image-item text-center p-2 border border-gray-200 rounded-lg shadow-sm bg-white flex flex-col justify-between">
                        <a href="${url}" target="_blank" title="Open image: ${filename}" class="block flex-grow image-container relative">
                            <div class="image-loader-spinner absolute inset-0 m-auto"></div>
                            <img src="${url}" alt="Funko Image" class="opacity-0" 
                                 onload="this.classList.remove('opacity-0'); this.previousElementSibling.style.display='none';"
                                 onerror="this.alt='Failed to load'; this.style.border='2px dashed #ef4444'; this.classList.remove('opacity-0'); this.previousElementSibling.style.display='none'; this.src='https://placehold.co/120x120/f87171/ffffff?text=Error';">
                        </a>
                        <a href="${url}" target="_blank" class="text-xs text-blue-600 hover:text-blue-800 hover:underline break-all block mt-2 pt-1 border-t border-gray-100" title="${filename}">
                            ${displayFilename}
                        </a>
                    </div>`;
            });
            html += '</div>';
            return html;
        }
    </script>
</body>
</html>
